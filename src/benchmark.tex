\section{Benchmarking MbArrays}
\label{sec:bench}

In high-level languages, arrays are rarely used explicitly in algorithms and data structures, as they are usually provided with a limited API which only offers basic operations such as element retrieval and update. Instead, arrays are often used as the underlying storage of more high-level collections, such as |ArrayBuffer|s and |Vector|s.

In the optic of measuring performance improvements brought by |MbArray|s combined with the miniboxing transformation in realistic scenarios, I implemented one of these collections: the |ArrayBuffer|. To be able to compute the improvement, a version using the |ClassTag| approach mentionned earlier in the paper is implemented in an identical manner. Hence, on top of the |@miniboxed| annotation, the only differences in the source code between the two versions appear where arrays are instantiated and where array types are referenced. 

\subsection{High-level Overview}

Quoting the official Scala documentation, an |ArrayBuffer| is: 
\begin{quote}
\textit{An implementation of the Buffer class using an array to represent the assembled sequence internally. Append, update and random access take constant time (amortized time). Prepends and removes are linear in the buffer size.} 
\end{quote}

On top of this, high-level features are provided with the implementation, such as |map| or |filter|. These methods are regularly used because they allow programmers to enhance their productivity significantly. For these reasons, these methods were the actual subjects of the benchmarks.

\subsection{ArrayBuffer implementation}

One of the properties of the |ArrayBuffer| is that it is dynamically resizable, which means it is possible to append elements to it even after it has been instantiated for a given size. For example: 

\begin{lstlisting-nobreak}
 val buf = new ArrayBuffer[int](2)
 buf(0) = 1
 buf(1) = 2
 buf.append(3) // buf now contains {1, 2, 3}
\end{lstlisting-nobreak}

However, this feature is not proposed by default by the underlying array (neither |Array| nor |MbArray| implements it). One way to implement this feature is to naively instantiate a new array of size $n + 1$ each time an element is appended, where $n$ is the current size of the array, and to then copy the previous content to the new one.
While it is simple to implement, it has major performance issues in case several append operations are done sequentially to a decently large array.
% example ?

 
Here, I will present how the different features are implemented:
\begin{itemize}
  \item |append|: when an item is appended to the |ArrayBuffer|, I use a classical growth policy, where 
  \item |apply|: 
  \item |update|: 
  \item |map|: 
  \item |filter|: 
\end{itemize}

\subsection{Benchmarking procedure}

\subsection{The Numbers}

%In the optic of experimenting real world scenarios with the miniboxing transformation