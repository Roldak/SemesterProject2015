\section{Benchmarking MbArrays}
\label{sec:bench}

In high-level languages, arrays are rarely used explicitly in algorithms and data structures, as they are usually provided with a limited API which only offers basic operations such as element retrieval and update. Instead, arrays are often used as the underlying storage of more high-level collections, such as |ArrayBuffer|s and |Vector|s.

In the optic of measuring performance improvements brought by |MbArray|s combined with the miniboxing transformation in realistic scenarios, I implemented one of these collections: the |ArrayBuffer|. To be able to compute the improvement, a version using the |ClassTag| approach mentionned earlier in the paper is implemented in an identical manner. Hence, on top of the |@miniboxed| annotation, the only differences in the source code between the two versions appear where arrays are instantiated and where array types are referenced. 

\subsection{High-level Overview}

Quoting the official Scala documentation, an |ArrayBuffer| is: 
\begin{quote}
\textit{An implementation of the Buffer class using an array to represent the assembled sequence internally. Append, update and random access take constant time (amortized time). Prepends and removes are linear in the buffer size.} 
\end{quote}

On top of this, high-level features are provided with the implementation, such as |map| or |filter|. These methods are regularly used because they allow programmers to enhance their productivity significantly. For these reasons, these methods were the actual subjects of the benchmarks.

\subsection{ArrayBuffer implementation}



\subsection{Benchmarking procedure}

\subsection{The Numbers}

%In the optic of experimenting real world scenarios with the miniboxing transformation