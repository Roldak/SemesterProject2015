\section{Contributions}
\label{sec:contrib}

% summary
In this section, I will present one by one the main aspects of my contribution to the Miniboxing plugin done during my semester project under the supervision of Vlad.
% (Initial benchmark => array access slowdown.)
% MbVector Benchmark
\subsection{Challenging the Assumptions} 

In the optic of experimenting real world scenarios with the miniboxing transformation, and in particular with |MbArray|s, I developped a straightforward implementation of a generic mutable |ArrayBuffer|. Furthermore, the project was divided in two equivalent versions, one which uses |MbArray|s as its underlying storage, and the other which uses raw Scala |Array|s with |ClassTag|s. Having these two versions not only allowed me to easily observe the benefits brought by |MbArray|s in terms of usability, but also made me able to benchmark the performance improvements that |MbArray|s ought to expose.

%   => Mapping a 3M elements MbVector was slow when using MbArrays because an MbArray[int] takes up to 2 times the memory that is actually necessary to store its integers, therefore triggering additional GC cycles which do no occur when using the Array of ClassTag version.

Unfortunately, running a simple benchmark over the |map| operations produced a disappointing result: |MbArray|s showed to be approximately $150\%$ times slower than their |Array| equivalent in this case. We convinced ourselves that the cause of the slowdown was not due to the miniboxing transformation by looking at the low level code that was generated for the benchmark through a custom JVM using relevant flags: we observed that the internal array of the homemade |ArrayBuffer| instantiated with an |Int| type parameter was using an |MbArray_J|, as expected, and that critical methods were inlined correctly. As a matter of fact, the reason for the slowdown was way less obvious than that. Indeed, when running the benchmark with the |-verbose:gc| JVM flag, we discovered that the version using |MbArray|s would trigger an additionnal GC cycle. [PROOF HERE]

% How to solve this problem ?
% One of the underlying assumptions of MbArrays is that an MbArray of an integral type uses an Array[Long] internally to store its data. As said above, the general transformation applied by the Miniboxing plugin will specialize the miniboxed code for 3 cases: Object references, Integral values (boxed into longs), Floating point values (boxed into doubles). Therefore, MbArrays would not need to have more than 3 different specializations: MbArray_L, MbArray_J, MbArray_D. 