\section{Contributions}
\label{sec:contrib}

% summary
In this section, I will present one by one the main aspects of my contribution to the Miniboxing plugin done during my semester project under the supervision of Vlad.

% (Initial benchmark => array access slowdown.)
% MbVector Benchmark
\textbf{Breaking the invariant.} In the optic of experimenting with the miniboxing transformation and particularly with |MbArray|s in real world scenarios, I developped a simple implementation of a generic mutable |ArrayBuffer|. Furthermore, the project was divided in two versions, one which uses |MbArray| as its underlying storage, and another one wich uses raw Scala |Array| with |ClassTag|s, so that we could easily observe the benefits brought by |MbArray|s. 

%   => Mapping a 3M elements MbVector was slow when using MbArrays because an MbArray[int] takes up to 2 times the memory that is actually necessary to store its integers, therefore triggering additional GC cycles which do no occur when using the Array of ClassTag version.

% How to solve this problem ?
% One of the underlying assumptions of MbArrays is that an MbArray of an integral type uses an Array[Long] internally to store its data. As said above, the general transformation applied by the Miniboxing plugin will specialize the miniboxed code for 3 cases: Object references, Integral values (boxed into longs), Floating point values (boxed into doubles). Therefore, MbArrays would not need to have more than 3 different specializations: MbArray_L, MbArray_J, MbArray_D. 