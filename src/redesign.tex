\section{Redesigning MbArrays}
\label{sec:redesign}

After having brought out the flow in the current |MbArray| design that slows down its performance, I will present the approach I took in order to address the issue.

\subsection{The Goal}

Ultimately, the goal is to keep the mechanisms in |MbArray|s that are working, but to decrease the memory needed for that.
To this end, the design change I opted for was adding more specializations to the |MbArray|s: one for each primitive type that exists in Scala. In other words, an |MbArray[Boolean]| would get transformed to |MbArray_B| which uses a |boolean[]| internally instead of the prevous |long[]|, and so on equivalently for every of the 10 primitive types that exist in Scala. Hopefully, this would result in less heap memory wasted and therefore a higher GC throughput.

\subsection{Design transformation}

Adding the 8 other specializations was fairly straightforward: All that had to be done was duplicating one of the two existing specialization for every new variants and changing the internal array type |Array[Long]| to the ones adapted for the different specialization.
Then, the code that handled |MbArray| instantiations, namely |MbArray_empty_J|, |MbArray_empty_D|, |MbArray_clone_J| and |MbArray_clone_D|, had to be modified in order to take into accounts the new specializations.
For example:

\begin{lstlisting-nobreak-java}
public static <T> MbArray<T> mbArray_empty_J(int size, byte T_Tag) {
  return new MbArray_J<T>(T_Tag, size);
}
\end{lstlisting-nobreak-java}

Was transformed to:

\begin{lstlisting-nobreak-java}
public static <T> MbArray<T> mbArray_empty_J(int size, byte T_Tag) {
  switch(T_Tag) {
  case MiniboxConstants.LONG:
    return new MbArray_J<T>(size);
  case MiniboxConstants.INT:
    return new MbArray_I<T>(size);
  case MiniboxConstants.SHORT:
    return new MbArray_S<T>(size);
  case MiniboxConstants.CHAR:
    return new MbArray_C<T>(size);
  case MiniboxConstants.BYTE:
    return new MbArray_B<T>(size);
  case MiniboxConstants.BOOLEAN:
    return new MbArray_Z<T>(size);
  case MiniboxConstants.UNIT:
    return new MbArray_V<T>(size);
  default:
    return new MbArray_L<T>(size);
  }
}
\end{lstlisting-nobreak-java}

Similarly, the |apply| and |update| methods had to be changed.
For example:

\begin{lstlisting-nobreak-java}
public static <T> long mbArray_apply_J(MbArray<T> mbArray, int index, byte T_Tag) {
  if (mbArray instanceof MbArray_J<?>)
    return ((MbArray_J<?>)mbArray).apply_J(index);
  else
    return MiniboxConversionsLong.box2minibox_tt(
    	mbArray.apply(index), T_Tag);
}
\end{lstlisting-nobreak-java}

Became:

\begin{lstlisting-nobreak-java}
public static <T> long mbArray_apply_J(MbArray<T> mbArray, int index, byte T_Tag) {
  if (mbArray instanceof MbArray_J<?>)
    return ((MbArray_J<?>)mbArray).apply_J(index);
  else if (mbArray instanceof MbArray_I<?>)
    return ((MbArray_I<?>)mbArray).apply_J(index);
  else if (mbArray instanceof MbArray_S<?>)
    return ((MbArray_S<?>)mbArray).apply_J(index);
  else if (mbArray instanceof MbArray_C<?>)
    return ((MbArray_C<?>)mbArray).apply_J(index);
  else if (mbArray instanceof MbArray_B<?>)
    return ((MbArray_B<?>)mbArray).apply_J(index);
  else if (mbArray instanceof MbArray_Z<?>)
    return ((MbArray_Z<?>)mbArray).apply_J(index);
  else if (mbArray instanceof MbArray_V<?>)
    return ((MbArray_V<?>)mbArray).apply_J(index);
  else
    return MiniboxConversionsLong.<T>box2minibox_tt(
    	mbArray.apply(index), T_Tag);
}
\end{lstlisting-nobreak-java}

\subsection{Re-benchmarking}

It is now time to compare the old numbers to the numbers we obtain by running the same benchmark with the new |MbArray|. Figure \ref{fig:NewCTvsMB} shows that the new version performs approximately at the same level as the |ClassTag| version on this benchmark. Moreover, figure \ref{fig:NewGcComp} shows how the new version spends |~|3 times less time collecting garbage than the old version, from which follows a |~100ms| runtime performance gain. One can note that one top of the gain coming from the reduced amount of time spent collecting garbage, the new version gets a boost of |~70ms| for other reasons. 

\begin{figure}
\subfigure[ClassTag version]{
	\lstinputlisting{BenchmarkOutputs/CtVector0.txt}	
	\label{fig:CtVector0}
}
\subfigure[Old Miniboxed version]{
	\lstinputlisting{BenchmarkOutputs/MbVector0.txt}
    \label{fig:MbVector0}
}
\subfigure[New Miniboxed version]{
	\lstinputlisting{BenchmarkOutputs/NewMbVector0.txt}
    \label{fig:NewMbVector0}
}
\caption{New Scalameter benchmark outputs}
\label{fig:NewCTvsMB}
\end{figure}  

\begin{figure}
\subfigure[ClassTag version]{
	\lstinputlisting{BenchmarkOutputs/CtVector1.txt}
	\label{fig:CtVector1}
}
\subfigure[Old Miniboxed version]{
	\lstinputlisting{BenchmarkOutputs/MbVector1.txt}
    \label{fig:MbVector1}
}
\subfigure[New Miniboxed version]{
	\lstinputlisting{BenchmarkOutputs/NewMbVector1.txt}
    \label{fig:NewMbVector1}
}
\caption{New benchmark outputs for ArrayBuffers of 10'000'000 elements}
\label{fig:NewGcComp}
\end{figure}

In this initial benchmark the |MbArray| version did not prove to be faster than the |ClassTag| version. However, most of the benchmark do show better numbers for the |MbArray|. For example, benchmark \ref{fig:OtherCTvsMB} shows that the version using new |MbArray|s can be approximately $250\%$ faster than the version using |ClassTag|s and $20\%$ faster than the version using the old |MbArray|s. In almost every cases, the version using new |MbArray|s is faster than the version using old |MbArray|s which essentially means that it is in some cases running equivalently fast as the |ClassTag| version -- as shows benchmark \ref{fig:NewCTvsMB} --, but is in most cases faster than the |ClassTag| version, benchmark \ref{OtherCTvsMB} being a good example of this.  

\begin{figure}
\subfigure[ClassTag version]{
	\lstinputlisting{BenchmarkOutputs/CtVector2.txt}	
	\label{fig:CtVector0}
}
\subfigure[Old Miniboxed version]{
	\lstinputlisting{BenchmarkOutputs/MbVector2.txt}
    \label{fig:MbVector0}
}
\subfigure[New Miniboxed version]{
	\lstinputlisting{BenchmarkOutputs/NewMbVector2.txt}
    \label{fig:NewMbVector0}
}
\caption{New Scalameter benchmark outputs}
\label{fig:OtherCTvsMB}
\end{figure}  

\begin{figure}
\subfigure[ClassTag version]{
	\lstinputlisting{BenchmarkOutputs/CtVector3.txt}
	\label{fig:CtVector1}
}
\subfigure[Old Miniboxed version]{
	\lstinputlisting{BenchmarkOutputs/MbVector3.txt}
    \label{fig:MbVector1}
}
\subfigure[New Miniboxed version]{
	\lstinputlisting{BenchmarkOutputs/NewMbVector3.txt}
    \label{fig:NewMbVector1}
}
\caption{New benchmark outputs for ArrayBuffers of 10'000'000 elements}
\label{fig:OtherGcComp}
\end{figure}